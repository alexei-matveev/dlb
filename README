
* DYNAMIC LOAD BALANCING

The library created in this subfolder (called libdlb.a) takes carea
bout dynamical load balancing.  There are two different cases
possible: one where all jobs are equal in name and a second one where
each job has a special color.  There are 6 different functions
altogether, where two are common ones, while of the other each two
belong to the case with and without color.


* DIFFERENT VARIANTS

Which of the different variants of the DLB implementions is used is
selected by DLB_VARIANT. In the case of DLB_VARIANT = 0 there is a
static distribution, where no communication between the processors is
used.

DLB_VARIANT = 1: is a remote memory access (RMA) method. When RMA is
    really asynchronous, or done by the hardware, this method can be
    uses.

DLB_VARIANT = 2 and DLB_VARIANT = 3: Both methods use threads for
    making the DLB algorithm work. They need a higher level of thread
    safety than the normal MPI_INIT. They should be run with
    MPI_INIT_THREAD, where the variant 2 needs at least level
    MPI_THREAD_SERIALIZED, while variant 3 needs
    MPI_THREAD_MULTIPLE. The start some threads to handle the
    MPI_communication between the processors. Variant 3 needs a good
    thread handling for blocking MPI calls. If this thread alternates
    nicely with the working thread this method should be better than
    variant 2, where this alternation is done by hand. But MPI has
    often an aggressive polling by blocking calls, where the variant 3
    easily doubles the time requirement.  The variants need also POSIX
    Threads available.

* ACTING OF DLB

DLB takes care about the available job numbers. On request it gives
several of this to a processor to work on. It takes care that each of
them is given back exactly once.  If a processor runs out of jobs, he
can, for DLB_VARIANT > 0, ask the other processors to give them some
of theirs.

* INTERFACE

All functions have to be called on all processors.  The two common
functions are: dlb_init and dlb_finalize. They have to surround the
use of the other functions.  When calling dlb_init MPI has to be
already initialized, also dlb finalize has to be called before
MPI_FINALIZE. Other than the MPI counterparts there is the possibility
to finalize and initialize dlb in between some uses.  Both functions
have no arguments, thus use them by:

    call dlb_init()
    ...
    call dlb_finalize()

The calculation itself is done by the two functions dlb_setup and
dlb_give_more (or their counterpart with colors dlb_setup_color and
dlb_give_more_color)

dlb_setup will take the number of available jobs as an argument. It
will already perform a statical distribution.

dlb_give_more has two arguments: the first MAXJOBS stands for the
number of job numbers it wants at once. The second argument is the
interval jobs, which the processor should now work on. The work the
processor should then do is between jobs(1) + 1 and
jobs(2). dlb_give_more is a function, which will return true as long
as there a jobs and false if there are none. In the last case there
will be also jobs(1) >= jobs(2). If it returns true there is always at
least one job.  But there may be also fewer, if the processor has only
few, this has nothing to do with the amount of jobs, all processors
have.  If it returns false, all processors have terminated (except in
case DLB_VARIANT = 0).  Otherwise it will wait in the function
dlb_give_more if the termination has not yet confirmed.

Usage:

    call dlb_setup(NJOBS)

    do while dlb_give_more(MAXJOBS, jobs)

Here NJOBS is integer, MAXJOBS is integer, jobs(2) is integer array

The difference of the color case, is that here the color is also
considered.  In dlb_setup_color one gives a distribution, with the
colors, thus it gets an integer array containing elements like
(/startnumber, endnumber, color/).  Where startnumber +1 to endnumber
a the jobsnumber on element color.  dlb_give_more_color will give in
addition to the jobs their color. Furthermore it ensures that all jobs
it gives back have the same color.

Usage:

    call dlb_setup_color(distr)

    do while dlb_give_more_color(MAXJOBS, color, jobs)

Here distr is integer array of size (many_colors, 3), MAXJOBS and
color are integers, jobs(2) is integer array.

Additionally there is a function for printing statistics. It is
possible to not print the output directly (see output_level below) but
also to give them summarized with the function
dlb_print_statistics. The output of this function is independent on
the output_level of the DLB module but the amount of output is
specified by an variable, given directly to it.  This functions need
some reude functions, thus it could cause some overhead. In case the
function gets level = 0 this step is also omitted and
dlb_print_statistics will return immediately.  For the static backend
of DLB only level 0 and 1 give reasonable results.

The output specified with the level is always including all smaller
levels:

level  | new output
0      | None
1      | SUM(time spend in dlb_give_more)  [last time separated]
2      | About how long waited for new tasks
3      | Time of last two batches spend outside DLB
4      | Statistics about task length (time between dlb_give_more calls) +
         complete time
         between dlb_setup and the finish of DLB

Usage:

    call dlb_print_statistics(level)

Here level is an integer.

* DLB AND THREAD SAFETY

Different implementations have different requirements concerning
thread safety, especially as some of the implementations build
explicitly on them. MPI provides some different MPI_THREAD_LEVELS,
which show what could be expected in that regard from the current
implementation.  Each dlb variant can show the required thread level,
as it is stored in the variable DLB_THREAD_REQUIRED, which is also
handed over to the general dlb wrapper.  But be aware that the thread
level is only for the usage of DLB. It is assumed that DLB will be the
only one to do some message passing in there. If the code, which uses
DLB should have also some thread level requirements one of course
needs to use the higher one, which should cause no problems to DLB. If
in the parts of the code using DLB contain some message passing also
one even might to raise the level again. This of course does not
affect MPI_THREAD_SINGLE and might not even affect MPI_THREAD_FUNNELED
but MPI_THREAD_SERIALIZED should then be raised to
MPI_THREAD_MULTIPLE.


* EXAMPLE

  use mpi
  use dlb
  integer :: ierr, prov, NJOBS, MAXJOBS, jobs(2), i
  integer :: distr(4,3), color

  call MPI_INIT_THREADS(MPI_THREAD_MULTIPLE, prov, ierr)

  call dlb_init()

  NJOBS = 20
  MAXJOBS = 2

  call dlb_setup(NJOBS)
  do while( dlb_give_more(MAXJOBS, jobs) )
     do i = jobs(1) + 1, jobs(2)
        print *, "Doing job", i
     enddo
  enddo

  MAXJOBS = 3
  distr(1,:) = (/1, 0, 10)
  distr(2,:) = (/0, 9, 13)
  distr(3,:) = (/2, 0, 1)
  distr(4,:) = (/3, 3, 9)

  call dlb_setup_color(distr)
  do while( dlb_give_more_color(MAXJOBS, color, jobs) )
     do i = jobs(1) + 1, jobs(2)
        print *, "Doing job", i, "of color", color
     enddo
  enddo

  call dlb_finalize()

  call MPI_FINALIZE(ierr)

* COMPILATION

If DLB is used external from the ParaGauss repository set DLB_EXTERNAL = 1 on
top of the DLB Makefile.

** OUTPUT LEVEL

DLB is able to run without producing output. But it may also provide
some informations and statistics up to very detailed informations
about its behavior.  What it will print of them is selected by the
output level.  The output level is defined by parameter OUTPUT_BORDER
in the Makefile.

OUTPUT_BORDER = 0: no output at all
OUTPUT_BORDER = 1: at initialization it will be printed which DLB
	           variant is used
OUTPUT_BORDER = 2: the DLB variants will also provide some more
                   statistics with summarized informations about the
                   run of DLB
OUTPUT_BORDER > 2: additional output will appear with time stamps at
                   some selected places
